from typing import List, Tuple, Callable, Any
from enum import Enum

import numpy as np

class GameContext:
    def __init__(self, character_class: CharacterClass, seed: int, ascension_level: int) -> None: ...
    def get_card_reward(self) -> List[Card]: ...
    @property
    def encounter(self) -> Any: ...
    @property
    def deck(self) -> List[Card]: ...
    def obtain_card(self, card: Card) -> None: ...
    def remove_card(self, idx: int) -> None: ...
    @property
    def relics(self) -> List[Relic]: ...
    screen_state_info: ScreenStateInfo
    outcome: GameOutcome
    act: int
    floor_num: int
    screen_state: ScreenState
    seed: int
    map: SpireMap
    cur_map_node_x: int
    cur_map_node_y: int
    cur_room: Room
    boss: Any
    cur_hp: int
    max_hp: int
    gold: int
    blue_key: bool
    green_key: bool
    red_key: bool
    card_rarity_factor: float
    potion_chance: float
    monster_chance: float
    shop_chance: float
    treasure_chance: float
    shop_remove_count: int
    speedrun_pace: int
    note_for_yourself_card: Any

class GameAction:
    @staticmethod
    def getAllActionsInState(gc: GameContext) -> List[GameAction]: ...
    def execute(self, gc: GameContext) -> None: ...
    def getDesc(self, gc: GameContext) -> str: ...
    @property
    def rewards_action_type(self) -> RewardsActionType: ...
    @property
    def idx1(self) -> int: ...
    @property
    def idx2(self) -> int: ...
    @property
    def idx3(self) -> int: ...

class Rewards:
    @property
    def gold(self) -> List[int]: ...
    @property
    def cards(self) -> List[NNCardRepresentation]: ...
    @property
    def relics(self) -> List[RelicId]: ...
    @property
    def potions(self) -> List[Potion]: ...
    emerald_key: bool
    sapphire_key: bool

class ScreenStateInfo:
    select_screen_type: CardSelectScreenType
    rewards_container: Rewards

class Relic:
    id: RelicId
    data: int

class SpireMap:
    def __init__(self, seed: int, width: int, height: int, is_daily: bool) -> None: ...
    def get_room_type(self, x: int, y: int) -> Room: ...
    def has_edge(self, x1: int, y1: int, x2: int, y2: int) -> bool: ...
    def edges(self, x: int, y: int) -> List[int]: ...
    def get_nn_rep(self) -> NNMapRepresentation: ...

class NNCardRepresentation:
    cards: np.ndarray
    upgrades: np.ndarray

    def __init__(self, cards: np.ndarray, upgrades: np.ndarray): ...

class NNRelicRepresentation:
    relics: List[int]
    relic_counters: List[int]

class NNMapRepresentation:
    xs: List[int]
    ys: List[int]
    room_types: List[int]
    edge_starts: List[int]
    edge_ends: List[int]

class NNRepresentation:
    fixed_observation: List[float]
    deck: NNCardRepresentation
    relics: NNRelicRepresentation
    map: NNMapRepresentation

class Card:
    def __init__(self, card_id: CardId) -> None: ...
    def upgrade(self) -> None: ...
    misc: int
    @property
    def id(self) -> CardId: ...
    @property
    def upgraded(self) -> bool: ...
    @property
    def upgrade_count(self) -> int: ...
    @property
    def innate(self) -> bool: ...
    @property
    def transformable(self) -> bool: ...
    @property
    def upgradable(self) -> bool: ...
    @property
    def is_strikeCard(self) -> bool: ...
    @property
    def is_starter_strike_or_defend(self) -> bool: ...
    @property
    def rarity(self) -> CardRarity: ...
    @property
    def type(self) -> CardType: ...

class Agent:
    def __init__(self) -> None: ...
    simulation_count_base: int
    boss_simulation_multiplier: float
    pause_on_card_reward: bool
    print_logs: bool
    def playout_battle(self, gc: GameContext) -> None: ...
    def playout(self, gc: GameContext) -> None: ...
    def pick_gameaction(self, gc: GameContext) -> GameAction: ...

class GameOutcome(Enum):
    UNDECIDED = ...
    PLAYER_VICTORY = ...
    PLAYER_LOSS = ...

class ScreenState(Enum):
    INVALID = ...
    EVENT_SCREEN = ...
    REWARDS = ...
    BOSS_RELIC_REWARDS = ...
    CARD_SELECT = ...
    MAP_SCREEN = ...
    TREASURE_ROOM = ...
    REST_ROOM = ...
    SHOP_ROOM = ...
    BATTLE = ...

class CardSelectScreenType(Enum):
    INVALID = ...
    TRANSFORM = ...
    TRANSFORM_UPGRADE = ...
    UPGRADE = ...
    REMOVE = ...
    DUPLICATE = ...
    OBTAIN = ...
    BOTTLE = ...
    BONFIRE_SPIRITS = ...

class RewardsActionType(Enum):
    CARD = ...
    GOLD = ...
    KEY = ...
    POTION = ...
    RELIC = ...
    CARD_REMOVE = ...
    SKIP = ...

class CharacterClass(Enum):
    IRONCLAD = ...
    SILENT = ...
    DEFECT = ...
    WATCHER = ...
    INVALID = ...

class Room(Enum):
    SHOP = ...
    REST = ...
    EVENT = ...
    ELITE = ...
    MONSTER = ...
    TREASURE = ...
    BOSS = ...
    BOSS_TREASURE = ...
    NONE = ...
    INVALID = ...

class CardRarity(Enum):
    COMMON = ...
    UNCOMMON = ...
    RARE = ...
    BASIC = ...
    SPECIAL = ...
    CURSE = ...
    INVALID = ...

class CardColor(Enum):
    RED = ...
    GREEN = ...
    PURPLE = ...
    COLORLESS = ...
    CURSE = ...
    INVALID = ...

class CardType(Enum):
    ATTACK = ...
    SKILL = ...
    POWER = ...
    CURSE = ...
    STATUS = ...
    INVALID = ...

class CardId(Enum):
    INVALID = ...
    ACCURACY = ...
    ACROBATICS = ...
    # ... (all other card IDs)
    ZAP = ...

class MonsterEncounter(Enum):
    INVALID = ...
    CULTIST = ...
    JAW_WORM = ...
    # ... (all other monster encounters)
    MYSTERIOUS_SPHERE_EVENT = ...

class RelicId(Enum):
    AKABEKO = ...
    ART_OF_WAR = ...
    # ... (all other relic IDs)
    INVALID = ...

class Potion:
    # Add Potion class definition if available
    pass

def play(agent: Agent, gc: GameContext) -> None: ...
def get_seed_str(seed: int) -> str: ...
def get_seed_long(seed_str: str) -> int: ...
def getFixedObservation(gc: GameContext) -> List[float]: ...
def getFixedObservationMaximums() -> List[float]: ...
def getNNRepresentation(gc: GameContext) -> NNRepresentation: ...

__version__: str
